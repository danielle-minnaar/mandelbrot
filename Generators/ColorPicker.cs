using System.Drawing;
using Mandelbrot.ExtensionMethods;
using Mandelbrot.Helpers.ColorKernels;
using Mandelbrot.Helpers.ColorKernels.Implementations;
using Mandelbrot.Model;

namespace Mandelbrot.Generators;

/// <summary>
///     Class that is used to turn raw Mandelbrot data into color images.
/// </summary>
public class ColorPicker
{
    private readonly Color[] _colorPalette;
    private double _colorSkew;
    private double _ditherRatio;
    private static string pallettesFolder = "Storage/Pallettes/";


    /// <summary>
    ///     Initializes a new instance of the
    ///     <see cref="ColorPicker"/> class.
    /// </summary>
    /// <param name="palletteName">
    ///     The name of the pallette file.
    ///     The file should be x by 1 in size.
    /// </param>
    public ColorPicker(string palletteName, double colorSkew = 1d, double ditherRatio = 0.2d)
    {
        _colorSkew = colorSkew;
        _ditherRatio = ditherRatio;

        var path = Path.Combine(
            pallettesFolder,
            palletteName);

        if (!File.Exists(path))
        {
            throw new FileNotFoundException($"Couldn't find this pallette: {path}");
        }

        var pallette = new Bitmap(path);
        var colorList = new List<Color> ();

        for (int i = 0; i < pallette.Width; i++)
        {
            var color = pallette.GetPixel(i, 0);
            colorList.Add(color);
        }

        _colorPalette = colorList.ToArray();
    }

    /// <summary>
    ///     Generate an image with color bands.
    /// </summary>
    /// <param name="iterData">
    ///     The data generated by the <see cref="Calculator"/> class.
    /// </param>
    /// <remarks>
    ///     The fastest type of coloring.
    /// </remarks>
    /// <returns>
    ///     A mandelbrot image with bounded colors, including meta data.
    /// </returns>
    public BrotImage GetBandedColor(IterationData iterData)
    {
        var kernel = new BandedKernel(iterData.Iterations, _colorPalette);

        var result = ImageLooper(iterData.SpaceParam.XSize, iterData.SpaceParam.YSize, kernel);

        var image = result.Item1;
        var colorTime = result.Item2;

        return iterData.ToBrotImage(image, colorTime);
    }

    /// <summary>
    ///     Generate an image with continuous coloring.
    /// </summary>
    /// <param name="iterData">
    ///     The raw data generated by the <see cref="Calculator"/> class.
    ///     Needs to have escape speeds in addition to iterations.
    /// </param>
    /// <returns>
    ///     A mandelbrot image with continuous coloring, including meta data.
    /// </returns>
    public BrotImage GetContinuousColor(IterationData iterData)
    {
        if (iterData.EscapeSpeeds is null)
        {
            return GetBandedColor(iterData);
        }

        var kernel = new ContinousKernel(iterData.EscapeSpeeds, _colorPalette, _colorSkew);
        var result = ImageLooper(iterData.SpaceParam.XSize, iterData.SpaceParam.YSize, kernel);

        var image = result.Item1;
        var colorTime = result.Item2;

        return iterData.ToBrotImage(image, colorTime);
    }

    public BrotImage GetDitheredColor(IterationData iterData)
    {
        if (iterData.EscapeSpeeds is null)
        {
            return GetBandedColor(iterData);
        }

        var kernel = new DitheredKernel(iterData.EscapeSpeeds, _colorPalette, _colorSkew, _ditherRatio);


        var result = ImageLooper(iterData.SpaceParam.XSize, iterData.SpaceParam.YSize, kernel);
        var image = result.Item1;
        var colorTime = result.Item2;

        return iterData.ToBrotImage(image, colorTime);
    }

    private static (Bitmap, TimeSpan) ImageLooper(int xSize, int ySize, IColorKernel kernel)
    {
        var startTime = DateTime.Now;

        var image = new Bitmap(xSize, ySize);

        for (int x = 0; x < xSize; x++)
        for (int y = 0; y < ySize; y++)
        {
            image.SetPixel(x, y,kernel.Apply(x, y));
        }

        var colorTime = DateTime.Now - startTime;
        return (image, colorTime);
    }
}