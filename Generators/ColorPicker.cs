using System.Drawing;
using Mandelbrot.ExtensionMethods;
using Mandelbrot.Model;

namespace Mandelbrot.Generators;

/// <summary>
///     Class that is used to turn raw Mandelbrot data into color images.
/// </summary>
public class ColorPicker
{
    private List<Color> colors = new List<Color>();
    private static string pallettesFolder = "Storage/Pallettes/";

    private List<double?> _escapeSpeedThresholds = new List<double?>();

    /// <summary>
    ///     Initializes a new instance of the
    ///     <see cref="ColorPicker"/> class.
    /// </summary>
    /// <param name="palletteName">
    ///     The name of the pallette file.
    ///     The file should be x by 1 in size.
    /// </param>
    public ColorPicker(string palletteName)
    {
        var path = Path.Combine(
            pallettesFolder,
            palletteName);

        if (!File.Exists(path))
        {
            throw new FileNotFoundException($"Couldn't find this pallette: {path}");
        }

        var pallette = new Bitmap(path);

        for (int i = 0; i < pallette.Width; i++)
        {
            var color = pallette.GetPixel(i, 0);
            colors.Add(color);
        }
    }

    /// <summary>
    ///     Generate an image with color bounds.
    /// </summary>
    /// <param name="iterationData">
    ///     The data generated by the <see cref="Calculator"/> class.
    /// </param>
    /// <returns>
    ///     The image, including meta data.
    /// </returns>
    public BrotImage GetColorFromIterations(IterationData iterationData)
    {
        var startTime = DateTime.Now;

        var iterations = iterationData.CalculationResults;
        var spaceParam = iterationData.SpaceParam;

        var image = new Bitmap(spaceParam.XSize, spaceParam.YSize);

        for (int x = 0; x < spaceParam.XSize; x++)
        {
            for (int y = 0; y < spaceParam.YSize; y++)
            {
                var color = GetColorFromIterations(iterations[x, y].Iterations,
                    iterationData.MinIterations,
                    iterationData.MaxIterations);
                image.SetPixel(x, y, color);
            }
        }

        var colorTime = DateTime.Now - startTime;

        return iterationData.ToBrotImage(image, colorTime);
    }

    /// <summary>
    ///     Generate an image with continuous coloring.
    /// </summary>
    /// <param name="iterationData">
    ///     The raw data generated by the <see cref="Calculator"/> class.
    ///     Needs to have escape speeds in addition to iterations.
    /// </param>
    /// <returns>
    ///     The image, including meta data.
    /// </returns>
    public BrotImage GetColorFromEscapeSpeed(IterationData iterationData)
    {
        var startTime = DateTime.Now;

        var escapeSpeeds = iterationData.CalculationResults;
        
        SetEscapeSpeedThresholds(escapeSpeeds);

        var spaceParam = iterationData.SpaceParam;
        var image = new Bitmap(spaceParam.XSize, spaceParam.YSize);

        for (int x = 0; x < spaceParam.XSize; x++)
        {
            for (int y = 0; y < spaceParam.YSize; y++)
            {
                var color = GetColorFromEscapeSpeed(escapeSpeeds[x, y].EscapeSpeed);
                image.SetPixel(x, y, color);
            }
        }

        var colorTime = DateTime.Now - startTime;

        return iterationData.ToBrotImage(image, colorTime);
    }

    private void SetEscapeSpeedThresholds(CalcResult[,] escapeSpeeds)
    {
        var numThresholds = colors.Count();

        var queryable = escapeSpeeds.Cast<CalcResult>();
        var count = queryable.Where(calc => calc.Iterations != 0).Count();
        var skipSize = count / numThresholds;
        var initialSkipSize = count % skipSize;

        var max = queryable.Max(calc => calc.EscapeSpeed);
        var min = queryable.Where(calc => calc.Iterations != 0).Min(calc => calc.EscapeSpeed);
        var result = queryable
            .Where(calc => calc.Iterations != 0)
            .OrderBy(calc => calc.EscapeSpeed)
            .Where((item, index) =>
                (index - initialSkipSize) % skipSize == 0)
            .Select(calc => calc.EscapeSpeed)
            .Skip(1)
            .SkipLast(1)
            .ToList()
            ;

        var final = new List<double?> { min };
        final.AddRange(result);
        final.Add(max);

        _escapeSpeedThresholds = final;
    }

    private Color GetColorFromEscapeSpeed(double? escapeSpeed)
    {
        if (escapeSpeed == 0 || escapeSpeed is null)
        {
            return Color.Black;
        }

        var colorId = 0;
        var lowerValue = _escapeSpeedThresholds[0];
        var higherValue = _escapeSpeedThresholds[_escapeSpeedThresholds.Count() - 1];
        for (int i = 0; i < _escapeSpeedThresholds.Count(); i++)
        {
            var threshold = _escapeSpeedThresholds[i];
            if (threshold < escapeSpeed && threshold > lowerValue)
            {
                lowerValue = threshold;
                colorId = Math.Min(i, colors.Count() - 1);
            }
            else if (threshold >= escapeSpeed && threshold < higherValue)
            {
                higherValue = threshold;
            }
        }

        var fraction = (escapeSpeed - lowerValue) / (higherValue - lowerValue);


        var color1 = colors[colorId];
        var color2 = colors[Math.Min(colorId + 1, colors.Count() - 1)];

        return InterpolateColors(color1, color2, fraction);
    }
    
    private static Color InterpolateColors(Color color1, Color color2, double? fraction)
    {
        if (fraction is null || fraction < 0 || fraction > 1)
        {
            throw new ArgumentException($"Bad fraction: {fraction}");
        }

        int R = (int)(color1.R + (color2.R - color1.R) * fraction);
        int G = (int)(color1.G + (color2.G - color1.G) * fraction);
        int B = (int)(color1.B + (color2.B - color1.B) * fraction);
        return Color.FromArgb(R, G, B);
    }
    
    /// <summary>
    ///     Get the appropriate color for a point in the image.
    /// </summary>
    /// <param name="iterations">
    ///     The number of iterations to escape the bound value for the point.
    /// </param>
    /// <param name="minIterations">
    ///     The minimum number of iterations of all points in the image
    ///     that lie outside the fractal.
    /// </param>
    /// <param name="maxIterations">
    ///     Tha maximum number of iterations of all points in the image
    ///     that lie outside the fractal.
    /// </param>
    /// <returns>
    ///     The <c>Color</c> that matches the number of iterations.
    /// </returns>
    public Color GetColorFromIterations(int iterations, int minIterations, int maxIterations)
    {
        if (iterations == 0)
        {
            return Color.Black;
        }
        
        // Scale iterations from 0 to 1
        var enumerator = (double)(iterations - minIterations + 1);
        var divisor = (double)(maxIterations - minIterations);
        var adjustedIterations = (double)enumerator / (double)divisor;

        // Scale from 0 to three times the number of colors
        adjustedIterations = adjustedIterations * colors.Count * 3;


        var slope = 2d / colors.Count;
        divisor = 1 + Math.Pow(Math.E, -1 * slope * adjustedIterations);

        var colorIndex = (2 / divisor - 1) * colors.Count;
        colorIndex = Math.Min(colorIndex, colors.Count - 1);
        
        // var colorIndex = Math.Min((int)(iterations - minIterations), colors.Count - 1);

        return colors[(int)colorIndex];
    }
}